<?xml version="1.0" encoding="US-ASCII"?> <!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"> <!ENTITY
RFC5280 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml"> <!ENTITY
RFC5905 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml"> <!ENTITY
RFC7384 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7384.xml"> ]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes"?>
<?rfc toc="no"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="info" docName="draft-aanchal-time-implementation-guidance-00" ipr="trust200902">
  <front>
    <title>On Implementing Time</title>

    <author fullname="Aanchal Malhotra" initials="A." surname="Malhotra">
        <organization>Boston University</organization>
        <address>
            <postal>
                <street>111 Cummington Mall</street>
                <city>Boston</city>
                <region></region>
                <code>02215</code>
                <country>USA</country>
            </postal>
            <email>aanchal4@bu.edu</email>
        </address>
    </author>

    <author fullname="Kristof Teichel" initials="K." surname="Teichel">
        <organization abbrev="PTB">Physikalisch-Technische Bundesanstalt</organization>
        <address>
            <postal>
                <street>Bundesallee 100</street>
                <city>Braunschweig</city>
                <region></region>
                <code>D-38116</code>
                <country>Germany</country>
            </postal>
            <email>kristof.teichel@ptb.de</email>
        </address>
    </author>
    
    <author fullname="Martin Hoffmann" initials="M." surname="Hoffmann">
        <organization>Open Netlabs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>martin@opennetlabs.com</email>
        </address>
    </author>
    
    <author fullname="Willem Toorop" initials="W." surname="Toorop">
        <organization>NLnet Labs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>willem@nlnetlabs.nl</email>
        </address>
    </author>

    <date year="2017" month="October" day="30"/>

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>timestamps</keyword>

    <keyword>timespans</keyword>

    <abstract>
      <t>This document describes the properties of different types of time values available on digital systems and provides guidance on choices of these time values to the implementors of applications that use time in some form to provide the basic functionality and security guarantees.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>
        It is hard to understate the importance of time in modern digital systems. 
        The functionality and security of distributed applications and those running locally on a system and that of network protocols hinges on some notion of time. 
        For implementation, these applications and protocols have to choose one of the many types of time values available on the system, each of which has its own specific properties. 
        However, currently these applications seem to be oblivious to the implications of choosing one or the other time value for implementation. 
        This behaviour can be attributed to: 
        a) the lack of clear understanding of the distinct properties of these time values, 
        b) trade-offs of using one or the other for an application, and 
        c) availability and compatibilty of these time values on different systems. 
        This document discusses a) and b). 
      </t>
      
      <t> 
        More specifically, in this document we first define different time values used by protocols and applications to express time. 
        We then define properties of time values maintained by modern digital systems. 
        Next we describe how systems obtain these time values and security considerations of using these time values to implement protocols and applications that use time. 
        Finally we discuss trade-offs between security and precision of choosing one or the other kind of time value. 
        The document aims to provide guidance to the implementors make an informed choice with an example of POSIX system. 
      </t>

     </section>

     <section title = "Scope of the document">
      <t> This document does not describe functionality that is specific to the architecture of a PC, or other devices such as phones, IoT devices, switches, routers, base stations, synchrophasors.  Nor is the document applicable to a specific operating system. Throughout the document we assume that one or the other time value is available on most devices. How these time values are available on different PCs, or other devices is out of scope of this document. We do not exactly recommend which time value should be used. We discuss the available options and trade-offs. The final decision would vary depending on the availability of the kind of time values and the security requirements of the specific application under implementation. 
      </t>
      <t>Note: Since there is a lack of standards on terminology related to time, we define some terms in the following section. Also, throughout the document, we define the terms as they become relevant. Different systems, depending on their OS, may use different terms for the same time values. A survey on this is not in the scope of this document. We leave it to implementors to find out how to access these times or how these times are available on the device or OS that they are working on that is suitable to the application that they are going to use this time for. We will provide an example in the end for Linux. 
      </t>
    </section>

      <section title = "Definitions">

        <t><list style = "symbols">

          <t>Time, Timescale: Time is an abstraction which determines the ordering of events in a given frame of reference called timescale.</t>

        <t>Oscillator: An oscillator is a device that outputs trigger signals, which are (to a given tolerance level) equidistant with respect to a timescale.</t>

        <t>(Physical) Clock, Counter: A (physical) clock is a device composed of an oscillator and a counter, where the counter records a number of cycles since its initialization, with increments triggered by the oscillator. </t>
      </list></t>
     </section>

    <section title = "Expressing Time">
    <t> Protocols and applications can express time in several forms, depending on whether or not universal agreement is required about that point in time. This section focuses on the differences between absolute time and relative time.</t>
    <t><list style = "symbols">
    <t> Absolute time expresses an absolute point in time (e.g., June 13, 2018 at 1:32:09pm). For instance, Unix Time is seconds since midnight January 1st, 1970, while Universal Coordinated Time (UTC) is an international time scale that forms the basis for the coordinated dissemination of standard frequencies and time signals  . Absolute time is often used to express the validity of objects with a limited lifetime that are shared over the network. In order to validate absolute time value, a system needs access to a reasonably close reference time, for instance one based on the UTC. </t>

    <t> Relative time measures the time interval that has elapsed from some reference point (e.g., 20 minutes from the time of your query). Relative time is commonly used in network protocols, e.g., to determine when a packet should be considered dropped, or e.g., to set Time To Live (TTL) values that govern the length of time for which an object is valid or usable. Relative time does not require access to the UTC time, or any other absolute time metric only the rate of passage of his time across different systems is important. </t>

</list></t>
     </section>

      <section title = "Keeping Time: Different Clocks">
          <t> Because time is relative to an observer, there cannot be a
              universally agreed upon time. At best we can achieve an
              approximation by updating our own observed time with a
              common reference time shared with other observers.</t>
          <t> As this reference time is what we naively assume clocks on a
              wall are showing, we shall call it the "wall time." </t>
          <t> An individual computer system's preception of time differs from
              this idealized wall time. Staying close to it requires some
              effort that comes with its own set of drawbacks. Systems
              therefore provide access to different types of clocks with
              different properties. <!-- Unfortunately, there is no standard
              terminology and definitions for these types. For the purpose of
              this document, we therefore define two different kinds of
              clocks that a system may or may not provide. --></t>

          <t><list style = "symbols">
              <t> Native Time: The relative time on a system is native time. At its most fundamental, a system has its own perception of time; its unmodified, native time. This time is typically measured by counting cycles of an oscillator but systems may also use process CPU times or thread CPU time (via timers from the CPU). The quality of this time is therefore dependent on either the stability of the oscillator or of the CPU timer. Native time is purely subjective time - no general meaning can be attached to any specific value. One can only obtain the relative time by comparing two values. Because native time is unaltered by any external or manula source, it is continuous and strictly monotonically increasing. Its value always grow at a steady pace, never decreases, never make unexpected jumps, and never skips. It is not subject to vulnerabilities or dependencies in external time sources. However, even if highly accurate oscillators or CPU timers are used, native time is subject to clock drift. Native time is not adjusted for the error introduced by clock drift. Thus th eaccuracy of this time is dependent on the clock drift which is further dependednt on factors including oscilator quality, system load, or ambient temperature, etc.</t>

              <t>World Time: The absolute time on a system is world time. One way to update system time is to manually enter the date and/or time.One can also set the system time from the local machine by using the hardware time, which is maintained by a battery-powered clock that persists upon reboot. Alternatively, one can get the absolute time from the Internet, using a variety of timing protocols including the Network Time Protocol2 (NTP), Chrony, SNTP, OpenNTP and others. There are several problems with relying on world time. First, manual configurations can be subject to errors and misconfiguration. Also, for some machines, when moving between time zones, the system time must be corrected manually. Second, because accessing the hardware time requires an I/O operation which is resource intensive, many systems use hardware time only upon reboot, to initialize the system time; subsequent updates to the system time are made either manually or through timing protocols. However, systems like microcontrollers that operate within embedded systems (e.g., Raspberry Pi, Arduino, etc.) often lack internal hardware to keep track of time. When embedded systems require synchronization with the absolute time, they typically initialize their base time upon reboot by obtaining the current time from an external source (e.g., a timeserver or an external clock), or by asking the user to manually enter the current time. Third, relying on Internet timing protocols opens up the system time to attack. Recent papers show vulnerabilities in NTP [57, 59, 58] and SNTP [73] that allow attackers to maliciously alter system time - pushing system time into the past or even into the future. Moreover, many of these time-shifting attacks can be performed by off-path attackers,who do not occupy a privileged position on the network between the victim system and its time sources on the Internet. Researchers have also demonstrated off-path denial of service attacks on timing protocols that prevent systems from synchronizing their clocks. The bottom line is that obtaining world time from an external sources create dependencies that can be exploited.

               </t>
                </list></t>
                  <!-- <section title="Adjusted Raw Time">
              <t> Even if highly accurate oscillators are used, raw time passes at a
                  slightly different rate than wall time. This difference is called
                  clock drift. It depends not only on the quality of the time source but
                  also on environmental factors such as temperature.</t>
              <t> When this drift is componsated by comparing the passage of raw time
                  to some external time source that is considered to be closer to
                  wall time, the result is "adjusted raw time." This adjustment doesn't
                  happen sporadically but rather, the rate of advance of time is slowed down or sped up slightly
                  until it approaches the reference time again. As a result, adjusted
                  raw time is still monotonic. Like raw time, adjusted raw time is
                  subjective with no specific meaning attached to its values.</t>
              <t> The most frequently used method of acquiring an external time source
                  is through network timing protocols such as NTP
                  <xref target="RFC5905"/>. As a
                  result, adjusted raw time is susceptible to vulnerabilites of these
                  protocols which may be exploited to maliciously manipulate this time.</t>
          </section> -->
          <!-- <section title="World Time">
              <t> With adjusted raw time, a system already has access to a time that
                  passes at a rate very similar to wall time. By adjusting the time
                  value so that it represents the time passed since an epoch, a
                  well-defined point of wall time such as seconds since midnight
                  January 1st, 1970 on Unix systems, time values themselves gather
                  meaning. The result is "real time."</t>
              <t> While it is often assumed that real time is set to match wall time,
                  this doesn't need to be the case. A system's operator is free to
                  change the value of real time at any time, likewise, system services
                  such as a local NTP client may decide to do so.</t>
              <t> As a consequence, real time is not monotonic. Not only may it
                  jump forward, its value may even decrease.</t>
          </section> -->
          <!-- <section title="Differences from Wall Time">
              <t> These three clock types differ from wall time in three aspects:</t>
              <t><list style="symbols">
                  <t> Both raw time and adjusted raw time can only represent differences
                      in time by comparing two clock values. Only real time provides
                      absolute time values that can be compared to wall time values.</t>
                  <t> On the other hand, raw time and adjusted raw time are always monotonic whereas real time may experience sudden changes in
                      value in either direction.</t>
                  <t> Only adjusted raw time and real time are subject to external adjustments so that time
                      passes at approximately the same rate as wall time. Raw time will
                      over time drift away due to inevitable imperfections of the clock.</t>
              </list></t>
          </section>
      </section>
 -->
    <!-- <section title="Expressing Time">
        <t> Protocols or applications can express time in one of the two forms,
            depending on whether global agreement over the point in time
            is necessary.</t>

        <section title="Time Stamps">
            <t> A "time stamp" expresses an absolute point in
                time. In order to reference the same point across multiple
                systems, it needs to be stated in wall time.</t>
            <t> Time stamps are often used to express the validity of
                objects with a limited lifetime that are shared over the
                network. For instance, PKIX certificates
                <xref target="RFC5280"/> carry two time stamps expressing
                their earliest and latest validity.</t>
            <t> In order to validate a time stamp, a system needs access to
                a clock that is reasonably close to wall time.</t>
        </section>

        <section title="Time Spans">
            <t> In contrast, a "time span" expresses a desired
                length of time. Examples of time spans are timeout values used
                in protocols to determine packet loss or Time to Live (TTL)
                values that govern the lifetime of a local copy of an object.</t>
            <t> While no access to wall time is necessary for correctly dealing
                with time spans, using a clock whose time passes at a different
                rate than wall time will result in different interpretations
                of time spans by different systems. However, in a network
                environment, the uncertainty introduced by differing transmission
                times is likely larger than that introduced by clock drift.</t>
        </section>
    </section>
    <section anchor="CURIMP" title = "Current Implementations and Their Flaws">
        <t>Currently, some software takes a common approach towards time stamps and time spans.
     Time stamps are registered with their wall time value, and time spans are registered with two time stamp values marking the start and the end of the span.
     Conversion of a time span into those time stamp markers is regularly based on real time.
  </t>
  <t>Note that the start of a time span will be the current (real) time in case of a TTL.
     So, in case something needs to be cached for a certain time, the start time stamp is irrelevant and it is registered together with only the (real) expiration time.</t>
  <t>Programmers might have had different reasons to base those markings on real time, for example:<list style="numbers">
    <t>A point in time is intuitively thought of as a wall clock time stamp.
    Time stamps from outside the software, which the software has to manage are already in wall clock time.
    The POSIX function to get the current (real) time which is regularly used for this, is gettimeofday(), which comes accross as something providing near wall clock time and which can be used for this purpose.
    </t>
    <t>Managing time stamps and time span similarly, prevents code complexity.
    <vspace blankLines="1" />
    For example, many software is organized around I/O event notification mechanisms like the POSIX select() and poll() system C API functions.
    These functions wait for a given time span for file descriptors to become ready to perform I/O.
    The given time span is determined by substracting the current real time value from smallest registered time stamp.
    When file descriptors are ready, the non-blocking I/O is performed, otherwise the given time span has passed and the action associated with the smallest registered time stamp needs to be performed.
    <vspace blankLines="1" />
    For this programming pattern, a sorted list of time stamps has to be maintained by the software.
    To avoid coding complexity, programmers might prefer a single list for both actual wall clock time stamps and those generated from real time to mark the end of a time span.
    </t>
  </list></t> -->

            <!-- <t>Using real time as a basis for the time stamps marking the start and end of a time span is bad because of the following reasons.
                </t> -->
            <!-- <t><list style="numbers">
                <t>It can be set or overwritten manually,</t>
            <t>It is subject to adjustments by timing protocols which on one hand is important to make sure that this time is in sync with the rest of the world but on the other hand makes it dependent on the correctness and security of timing protocols.</t>
            </list></t>
           <t> Recent attacks <xref target="SECNTP"></xref>, <xref target="MCBG"></xref> show how timing protocols like NTP can be leveraged to shift real time on systems.</t> -->
           <t>Absolute time is always based on wall time, so the best one can do is to use world time while dealing with them. However, this limitation does not hold for the relative time. Managing relative time may be implemented in alternative ways which may prove to be more secure and robust.</t>
           
        <!-- <t><list>
        <t>An obvious question to ask is: Why do we need inception and expiration time stamps in the first place to define the validity period of cryptographic objects?
     Why can't we just use time spans like TTL values instead?
           The reason is straightforward.
     <vspace blankLines="1" />
     The authority determining and setting the validity period on the object can be different from the operator delivering the object.
     For example the TTL value on DNS resource records indicates to caching DNS resolvers how long to cache those records.
     These are an operational matter and are thus left to the operators of the DNS zone.
     <vspace blankLines="1" />
     The content of the resource records are however determined by the signer of the records.
     When she is not also the zone operator, she has no way to determine when the records will be queried for, and thus has to depend on cryptographically signed wall clock based time stamps to limit the validity.
     <vspace blankLines="1" />
     Note however that DNSSEC signatures do contain the original TTL of a resource record set, restricting the maximum TTL value with which the operator may deliver the resource records.  </t>
  </list></t> -->
        
  <t>Since we have no choice but to use world time for absolute time, for the rest of the document we only discuss the case of relative time.</t>

  </section>
    <section anchor="ALTIMP" title = "Alternative Approaches">
        <t>For relative time, where we only need the rate of passage of time to be close enough to the rest of the world, one does not have to necessarily rely on world time to establish the start and end time for the reasons mentioned above.</t>
          <t> The other type of time is native time. The important aspect of this monotonic time source is not its current value but the guarantee that the time source is linearly increasing and thus useful for calculating the difference in time between two samplings. But it comes with its own caveats.</t>
        <t><list>
            <t> Native time is not subject to any adjustments by timing protocols, i.e., it is not adjusted for the error introduced by clock drift. This could have two repercussions. First, this makes the correctness of native time independent from the errors or security vulnerabilities of the timing protocols. Second, its correctness depends on the clock drift which further depends on various factors such as quality of the oscillator, work load, or ambient temperature on the system and may vary.</t>
            <!-- <t> Adjusted raw time, on the other hand, is subject to adjustments by timing protocols. While it therefore compensates
                for the errors introduced by the drift of the local clock, this time can be incorrect as it is
                vulnerable to accuracy and security vulnerabilities of the underlying timing protocol.</t> -->
           </list></t>
            
            <t>The choice of time value to be used is application-specific. For instance in applications that can tolerate a certain amount of clock drift, implementers can use native time. However, if that is an issue then one has no choice but to fall back to world time.</t>

          </section>
  <section title = "POSIX example">

  <t>POSIX defines a system C API function which may provide native time: clock_gettime(), when used with a clock_id of CLOCK_MONOTONIC (when supported by the system). POSIX does not make a distinction between raw time and adjusted raw time in the definition of this function. Beware that with some systems, CLOCK_MONOTONIC deliveres adjusted raw time and that CLOCK_MONOTONIC_RAW needs to be used as clock_id to get unadjusted raw time. Non-POSIX systems may provide different APIs</t>
   
    <t>Software employing the pattern organized around I/O event notification mechanisms, as described in previous section, should maintain two sorted lists of two different types of time stamps:<list style="numbers">
  <t>One to register events based on time stamps expressed in wall clock time</t>
  <t>One to register the start and end of time spans in (adjusted) raw time</t>
  </list></t>
  <t>To determine the timeout value for a call to select() or poll(), the program needs to get the current time in both real time and in (adjusted) raw time.
  The current real time is substracted from the lowest value of the time stamps expressed in wall time list.
  The current (adjusted) raw time from the lowest value of the time stamps expressed in (adjusted) raw time list.
  The lowest of the values should be used as the timeout value for select() or poll() and determines which action should be performed when te function times out.</t>
  <t>Alternatively a single list of (adjusted) raw time could be used for both time stamps and time spans.
     In that case time stamps expressed in wall clock time should be converted into (adjusted) raw time, by first converting it into a time span by substracting real time from it, and then adding the current time in (adjested) raw time.</t>
        </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We are thankful to Sharon Goldberg and Benno Overreinder for useful 
        discussions.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>
        
    <section title = "Security Considerations">
      <t>Time is a fundamental component for the security guarantees claimed by various applications. A system that uses a time distribution protocol may be affected by the security aspects of the time protocol. The security considerations of time protocols in general are discussed in <xref target="RFC7384"/>.  This document discusses the security considerations with respect to implementing time values in applications in various sections.
        
      </t>
        </section>
  </middle>

  <back>
    <references title="Informative References">
      &RFC5280;
      &RFC5905;
      &RFC7384;

      <reference anchor="SECNTP" target="http://eprint.iacr.org/2016/1006">
        <front>
          <title>The Security of NTP's Datagram Protocol</title>

          <author initials="A." surname="Malhotra" fullname="A. Malhotra">
            <organization/>
          </author>
          <author initials="M. V." surname="Gundy" fullname="M. V. Gundy">
            <organization/>
          </author>
          <author initials="M." surname="Varia" fullname="M. Varia">
            <organization/>
          </author>
          <author initials="H." surname="Kennedy" fullname="H. Kennedy">
            <organization/>
          </author>
          <author initials="J." surname="Gardner" fullname="J. Gardner">
            <organization/>
          </author>
          <author initials="S." surname="Goldberg" fullname="S. Goldberg">
            <organization/>
          </author>

          <date year="2016"/>
          </front>
          </reference>
        
      <reference anchor="MCBG" target="https://eprint.iacr.org/2015/1020">
        <front>
            <title>Attacking the Network Time Protocol</title>
            
            <author initials="A." surname="Malhotra" fullname="A. Malhotra">
                <organization/>
            </author>
            <author initials="I." surname="Cohen" fullname="I. Cohen">
                <organization/>
            </author>
            <author initials="E." surname="Brakke" fullname="E. Brakke">
                <organization/>
            </author>
            <author initials="S." surname="Goldberg" fullname="S. Goldberg">
                <organization/>
            </author>
            
            <date year="2015"/>
        </front>
      </reference>

      <reference anchor="CLOCKDRIFT" target="http://downloads.hindawi.com/journals/jcnc/2008/583162.pdf">
        <front>
            <title>Internal clock drift estimation in computer clusters</title>
            
            <author initials="H." surname="Marouani" fullname="H. Marouani">
                <organization/>
            </author>
            <author initials="M. R." surname="Dagenais" fullname="M. R. Dagenais">
                <organization/>
            </author>
            <date year="2008"/>
        </front>
      </reference>

    </references>
  </back>
</rfc>
