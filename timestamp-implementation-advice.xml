<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC5280 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5280.xml">
<!ENTITY RFC5905 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5905.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes"?>
<?rfc toc="no"?>
<?rfc tocdepth="3"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-aanchal-time-implementation-guidance-00" ipr="trust200902">
  <front>
    <title>On Implementing Time</title>

    <author fullname="Aanchal Malhotra" initials="A." surname="Malhotra">
        <organization>Boston University</organization>
        <address>
            <postal>
                <street>111 Cummington Mall</street>
                <city>Boston</city>
                <region></region>
                <code>02215</code>
                <country>USA</country>
            </postal>
            <email>aanchal4@bu.edu</email>
        </address>
    </author>
    
    <author fullname="Martin Hoffmann" initials="M." surname="Hoffmann">
        <organization>Open Netlabs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>martin@opennetlabs.com</email>
        </address>
    </author>
    
    <author fullname="Willem Toorop" initials="W." surname="Toorop">
        <organization>NLnet Labs</organization>
        <address>
            <postal>
                <street>Science Park 400</street>
                <city>Amsterdam</city>
                <region></region>
                <code>1098 XH</code>
                <country>Netherlands</country>
            </postal>
            <email>willem@nlnetlabs.nl</email>
        </address>
    </author>

    <date year="2017" month="October" day="30"/>

    <area>General</area>

    <workgroup>Internet Engineering Task Force</workgroup>

    <keyword>timestamps</keyword>

    <keyword>timespans</keyword>

    <abstract>
      <t>This document describes the properties of different types of time
        values available on digital systems and provides guidance on choices of these time values to the implementors of applications that use time in some form to provide the basic functionality and security guarantees.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>The basic functionality and security guarantees claimed by many
        applications running on digital systems locally or in the Internet hinge on some notion of time. These applications have to choose one of the many types of time values available on the system, each of which has its own specific properties. However, currently these
        applications seem to be oblivious to the implications of choosing one or the other time value for implementation. This behaviour can be attributed to: a) the lack of clear understanding of the distinct properties of these time values, b) trade-offs of using one or the other for an application, and c) availability and compatibilty of these time values on different operating systems.</t>

        <t>In this document we describe the properties of various available time values on modern operating systems, discuss the trade-offs of using one over the other, and provide guidance to help implementors make an informed choice with some real-life examples.</t>
     </section>

    <section title="Keeping Time: Wall Time and Various Clocks">
      <t>
        Even if one ignores the intricacies introduced by the relative nature
        for a Newtonian view of an absolute time ticking away at a constant
        rate, the varying inaccuracies of all practical time-keeping devices
        make agreeing on a precise time difficult.
        An approximation can be achieved by first defining how to arrive
        at a shared reference time and then updating one's own clocks every
        now and then.
      </t><t>
        Such a reference time is called a time scale. There are several
        scales, but the most commonly used one is the Universal
        Coordinated Time (UTC). As it represents what we naively think every
        clock on a wall should be showing, we shall refer to it as "wall
        time."
      </t><t>
        One curious property of UTC is that because it attempts to keep in
        sync with the Earth's varying rotation, occassional leap seconds are
        required. As a consequence, the difference between two UTC time
        values is not necessarily equal to the time passed.

        <!-- What is a good term for this property that UTC is missing? -->
      </t><t>
        An individual computer system's perception of time cannot be derived
        directly from this wall time. Rather, it has to start from its own
        internal time-keeping mechanism, i.e., its own internal clock, and
        constantly update any differences to wall time using mechanisms
        such as NTP <xref target="RFC5905"/>.
      </t><t>
        Because these mechanisms come with their own difficulties and
        drawbacks, systems may provide access to different types of clocks
        with varying properties.
        Unfortunately, there is no standard
        terminology and definitions for these types. For the purpose of
        this document, we therefore define three different kinds of
        clocks that a system may or may not provide.
      </t>
      <section title="Raw Clock">
        <t>
          At its most fundamental, a system may provide access to its own,
          unadultered perception of time, its "raw clock." This clock is
          typically measuring time by counting cycles of an oscillator. Its
          quality therefore relies on the stability of this oscillator.
        </t><t>
          As it is a purely subjective time; no general meaning can be
          attached to any specific value. Only the amount of time passed
          can be determined by comparing two values.
        </t><t>
          Because the raw clock is an unaltered counter, its is strictly
          monotonically increasing. Its values will always grow at a steady
          pace, never decrease, never make unexpected jumps, or stop.

          <!-- Would it be fair to say that the raw clock is linear? -->
        </t>
      </section>
      <section title="Adjusted Raw Clock">
        <t>
          Even if highly accurate oscillators are used, a raw clock measures
          time at a rate slightly differening from  wall time. This difference
          is called "clock drift." It depends not only on the quality of the
          time source but also on environmental factors such as temperature.
          That is, drift will not be constant for a given clock but may
          increase or decrease over time.
        </t><t>
          When this drift is componsated by comparing the time of the raw clock
          to some external time source that is considered to be closer to wall
          time, the result is the "adjusted raw clock." This adjustment doesn't
          happen sporadically but rather, the rate of advance of time is slowed
          down or sped up slightly until it approaches the reference time again.
          As a result, adjusted raw time is still strictly monotonic
          increasing. Like the raw clock, the adjusted raw clock is subjective
          with no specific meaning attached to its values.
        </t><t>
          Since it can only work with an external time source, the adjusted
          raw clock may is susceptible to vulnerabilites of these sources,
          which may be exploited to maliciously manipulate this time.
        </t>
      </section>
      <section title="Real Time Clock">
        <!-- Maybe we need a better name now? -->
        <t>
          With the adjusted raw clock, a system already has access to a time
          source that passes at a rate very similar to wall time. By
          adjusting the time value so that it represents the time passed
          since an epoch, a well-defined point of wall time such as seconds
          since midnight January 1st, 1970 on Unix systems, time values
          themselves gather meaning. The result is a "real time clock."
        </t><t>
          While it is often assumed that real time is set to match wall time,
          this doesn't need to be the case. A system's operator is free to
          change the value of real time at any time, likewise, system services
          such as a local NTP client may decide to do so.
        </t><t>
          As a consequence, the real time clock is not strictly monotonically
          increasing.  Not only may it jump forward, its values may even
          decrease.
        </t>
      </section>
      <section title="Differences from Wall Time">
        <t>
          These three clock types differ from wall time in three aspects:
        </t>
        <t><list style="symbols">
          <t>
            Both raw clock and adjusted raw clock can only represent
            differences in time by comparing two clock values. Only the real
            time clock provides absolute time values that can be compared to
            wall time values.
          </t><t>
            On the other hand, raw clock and adjusted raw clock are always
            strictly monotonically increasing whereas the real time clock may
            experience sudden changes in value in either direction.
          </t><t>
            Only adjusted raw clock and real time clock are subject to
            external adjustments so that time passes at approximately the
            same rate as wall time. The raw clock will over time drift away
            due to inevitable imperfections of the clock. Conversely, the
            raw clock is imune to any manipulations introduced via the
            external adjustments.
          </t>
        </list></t>
      </section>
  </section>

    <section title="Expressing Time">
        <t> Protocols or applications can express time in one of the two forms,
            depending on whether global agreement over the point in time
            is necessary.</t>

        <section title="Time Stamps">
            <t> A "time stamp" expresses an absolute point in
                time. In order to reference the same point across multiple
                systems, it needs to be stated in wall time.</t>
            <t> Time stamps are often used to express the validity of
                objects with a limited lifetime that are shared over the
                network. For instance, PKIX certificates
                <xref target="RFC5280"/> carry two time stamps expressing
                their earliest and latest validity.</t>
            <t> In order to validate a time stamp, a system needs access to
                a clock that is reasonably close to wall time.</t>
        </section>

        <section title="Time Spans">
            <t> In contrast, a "time span" expresses a desired
                length of time. Examples of time spans are timeout values used
                in protocols to determine packet loss or Time to Live (TTL)
                values that govern the lifetime of a local copy of an object.</t>
            <t> While no access to wall time is necessary for correctly dealing
                with time spans, using a clock whose time passes at a different
                rate than wall time will result in different interpretations
                of time spans by different systems. However, in a network
                environment, the uncertainty introduced by differing transmission
                times is likely larger than that introduced by clock drift.</t>
        </section>
    </section>
    <section anchor="CURIMP" title = "Current Implementations and Their Flaws">
        <t>Currently, some software takes a common approach towards time stamps and time spans.
	   Time stamps are registered with their wall time value, and time spans are registered with two time stamp values marking the start and the end of the span.
	   Conversion of a time span into those time stamp markers is regularly based on real time.
	</t>
	<t>Note that the start of a time span will be the current (real) time in case of a TTL.
	   So, in case something needs to be cached for a certain time, the start time stamp is irrelevant and it is registered together with only the (real) expiration time.</t>
	<t>Programmers might have had different reasons to base those markings on real time, for example:<list style="numbers">
	  <t>A point in time is intuitively thought of as a wall clock time stamp.
	  Time stamps from outside the software, which the software has to manage are already in wall clock time.
	  The POSIX function to get the current (real) time which is regularly used for this, is gettimeofday(), which comes accross as something providing near wall clock time and which can be used for this purpose.
	  </t>
	  <t>Managing time stamps and time span similarly, prevents code complexity.
	  <vspace blankLines="1" />
	  For example, many software is organized around I/O event notification mechanisms like the POSIX select() and poll() system C API functions.
	  These functions wait for a given time span for file descriptors to become ready to perform I/O.
	  The given time span is determined by substracting the current real time value from smallest registered time stamp.
	  When file descriptors are ready, the non-blocking I/O is performed, otherwise the given time span has passed and the action associated with the smallest registered time stamp needs to be performed.
	  <vspace blankLines="1" />
	  For this programming pattern, a sorted list of time stamps has to be maintained by the software.
	  To avoid coding complexity, programmers might prefer a single list for both actual wall clock time stamps and those generated from real time to mark the end of a time span.
	  </t>
	</list></t>

            <t>Using real time as a basis for the time stamps marking the start and end of a time span is bad because of the following reasons.
                </t>
            <t><list style="numbers">
                <t>It can be set or overwritten manually,</t>
            <t>It is subject to adjustments by timing protocols which on one hand is important to
                make sure that this time is in sync with the rest of the world but on the other
                hand makes it dependent on the correctness and security of timing protocols.</t>
            </list></t>
           <t> Recent attacks <xref target="SECNTP"></xref>, <xref target="MCBG"></xref> show how timing protocols
               like NTP can be leveraged to shift real time on systems.</t>
           <t>Time stamps are always based on wall time, so the best one can do is to use real time
               while dealing with them. However, this limitation does not hold for the time spans.
	       Managing time spans may be implemented in alternative ways which may prove to be more secure and robust.</t>
           
        <t><list>
        <t>An obvious question to ask is: Why do we need inception and expiration time stamps in the first place to define the validity period of cryptographic objects?
	   Why can't we just use time spans like TTL values instead?
           The reason is straightforward.
	   <vspace blankLines="1" />
	   The authority determining and setting the validity period on the object can be different from the operator delivering the object.
	   For example the TTL value on DNS resource records indicates to caching DNS resolvers how long to cache those records.
	   These are an operational matter and are thus left to the operators of the DNS zone.
	   <vspace blankLines="1" />
	   The content of the resource records are however determined by the signer of the records.
	   When she is not also the zone operator, she has no way to determine when the records will be queried for, and thus has to depend on cryptographically signed wall clock based time stamps to limit the validity.
	   <vspace blankLines="1" />
	   Note however that DNSSEC signatures do contain the original TTL of a resource record set, restricting the maximum TTL value with which the operator may deliver the resource records.  </t>
	</list></t>
        
	<!-- <t>Since we have no choice but to use real time for time stamps, for the rest of the document we only discuss the case of time spans.</t> -->

        </section>
    <section anchor="ALTIMP" title = "Alternative Approaches">
        <t>For time spans, where we only need the rate of passage of time to be close enough to the rest of the world,
            one should not use the real time to establish the start and end time for the reasons mentioned above.
            The other two types of time are raw time and adjusted raw time. The important aspect of these monotonic time
            sources is not their current value but the guarantee that the time source is strictly linearly increasing and
            thus useful for calculating the difference in time between two samplings. But each comes with its own caveats.</t>
        <t><list>
            <t> Raw time is not subject to any adjustments by timing protocols, i.e., it is not adjusted for the error
                introduced by clock drift. This could have two repercussions. First, this
                makes correctness of raw time independent from the errors or security vulnerabilities of the timing protocols. Second, its
                correctness depends on the clock drift which further depends on various factors such as quality of the oscillator,
                work load, or ambient temperature on the system and may vary.</t>
            <t> Adjusted raw time, on the other hand, is subject to adjustments by timing protocols. While it therefore compensates
                for the errors introduced by the drift of the local clock, this time can be incorrect as it is
                vulnerable to accuracy and security vulnerabilities of the underlying timing protocol.</t>
           </list></t>
            
            <t>The choice of time value to be used is application-specific. For instance in applications that can tolerate a certain amount of
                <xref target="CLOCKDRIFT">clock drift</xref>, implementers can use raw time. However, if that is an issue then one has no choice but to fall back to adjusted raw time.</t>
	<t>POSIX defines a system C API function which may provide raw time: clock_gettime(), when used with a clock_id of CLOCK_MONOTONIC (when supported by the system).
           POSIX does not make a distinction between raw time and adjusted raw time in the definition of this function.
	   Beware that with some systems, CLOCK_MONOTONIC deliveres adjusted raw time and that CLOCK_MONOTONIC_RAW needs to be used as clock_id to get unadjusted raw time.
	   Non-POSIX systems may provide different APIs</t>
   
    <t>Software employing the pattern organized around I/O event notification mechanisms, as described in <xref target="CURIMP" />, should maintain two sorted lists of two different types of time stamps:<list style="numbers">
	<t>One to register events based on time stamps expressed in wall clock time</t>
	<t>One to register the start and end of time spans in (adjusted) raw time</t>
	</list></t>
	<t>To determine the timeout value for a call to select() or poll(), the program needs to get the current time in both real time and in (adjusted) raw time.
	The current real time is substracted from the lowest value of the time stamps expressed in wall time list.
	The current (adjusted) raw time from the lowest value of the time stamps expressed in (adjusted) raw time list.
	The lowest of the values should be used as the timeout value for select() or poll() and determines which action should be performed when te function times out.</t>
	<t>Alternatively a single list of (adjusted) raw time could be used for both time stamps and time spans.
	   In that case time stamps expressed in wall clock time should be converted into (adjusted) raw time, by first converting it into a time span by substracting real time from it, and then adding the current time in (adjested) raw time.</t>
        </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We are thankful to Sharon Goldberg and Benno Overreinder for useful 
        discussions.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This memo includes no request to IANA.</t>
    </section>
        
    <section title = "Security Considerations">
      <t>Time is a fundamental component for the security guarantees claimed by various applications. Therefore, any implementor concerned with security should be concerned with how these time values are implemented. This document discusses the security considerations with respect to implementing time values in applications in various sections.
        
      </t>
        </section>
  </middle>

  <back>
    <references title="Informative References">
      &RFC5280;
      &RFC5905;

      <reference anchor="SECNTP" target="http://eprint.iacr.org/2016/1006">
        <front>
          <title>The Security of NTP's Datagram Protocol</title>

          <author initials="A." surname="Malhotra" fullname="A. Malhotra">
            <organization/>
          </author>
          <author initials="M. V." surname="Gundy" fullname="M. V. Gundy">
            <organization/>
          </author>
          <author initials="M." surname="Varia" fullname="M. Varia">
            <organization/>
          </author>
          <author initials="H." surname="Kennedy" fullname="H. Kennedy">
            <organization/>
          </author>
          <author initials="J." surname="Gardner" fullname="J. Gardner">
            <organization/>
          </author>
          <author initials="S." surname="Goldberg" fullname="S. Goldberg">
            <organization/>
          </author>

          <date year="2016"/>
          </front>
          </reference>
        
      <reference anchor="MCBG" target="https://eprint.iacr.org/2015/1020">
        <front>
            <title>Attacking the Network Time Protocol</title>
            
            <author initials="A." surname="Malhotra" fullname="A. Malhotra">
                <organization/>
            </author>
            <author initials="I." surname="Cohen" fullname="I. Cohen">
                <organization/>
            </author>
            <author initials="E." surname="Brakke" fullname="E. Brakke">
                <organization/>
            </author>
            <author initials="S." surname="Goldberg" fullname="S. Goldberg">
                <organization/>
            </author>
            
            <date year="2015"/>
        </front>
      </reference>

      <reference anchor="CLOCKDRIFT" target="http://downloads.hindawi.com/journals/jcnc/2008/583162.pdf">
        <front>
            <title>Internal clock drift estimation in computer clusters</title>
            
            <author initials="H." surname="Marouani" fullname="H. Marouani">
                <organization/>
            </author>
            <author initials="M. R." surname="Dagenais" fullname="M. R. Dagenais">
                <organization/>
            </author>
            <date year="2008"/>
        </front>
      </reference>

    </references>
  </back>
</rfc>
